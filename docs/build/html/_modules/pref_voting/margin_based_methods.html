<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <meta name="generator" content="sphinx-4.2.0, furo 2022.06.21"/>
        <title>pref_voting.margin_based_methods - Preferential Voting Tools</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=40978830699223671f4072448e654b5958f38b89" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Preferential Voting Tools</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Preferential Voting Tools</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Elections</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../edata_overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../profiles.html">Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../profiles_with_ties.html">Profiles with Ties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../margin_graphs.html">(Weighted) Majority Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generate_profiles.html">Generate Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generate_weighted_majority_graphs.html">Generate Weighted Majority Graphs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Voting Methods</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../vms_overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scoring_methods.html">Positional Scoring Rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iterative_methods.html">Iterative Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../c1_methods.html">C1 Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../margin_based_methods.html">Margin Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../combined_methods.html">Combined Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other_methods.html">Other Methods</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for pref_voting.margin_based_methods</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    File: margin_based_methods.py</span>
<span class="sd">    Author: Eric Pacuit (epacuit@umd.edu)</span>
<span class="sd">    Date: January 10, 2022</span>
<span class="sd">    Update: July 31, 2022</span>
<span class="sd">    </span>
<span class="sd">    Implementations of voting methods that work on both profiles and margin graphs.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pref_voting.voting_method</span> <span class="kn">import</span>  <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pref_voting.helper</span> <span class="kn">import</span> <span class="n">get_mg</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">chain</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<div class="viewcode-block" id="minimax"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.minimax">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Minimax&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">minimax</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Minimax winners are the candidates with the smallest maximum pairwise defeat.  That is, for each candidate :math:`a` find the biggest margin of a candidate :math:`b` over :math:`a`, then elect the candidate(s) with the smallest such loss. Also known as the Simpson-Kramer Rule.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.minimax_scores`</span>

<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_minimax.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. code-block:: </span>

<span class="sd">        from pref_voting.margin_based_methods import minimax</span>

<span class="sd">        minimax.display(prof)</span>


<span class="sd">    .. exec_code:: </span>
<span class="sd">        :hide_code:</span>

<span class="sd">        from pref_voting.profiles import Profile</span>
<span class="sd">        from pref_voting.margin_based_methods import minimax</span>
<span class="sd">        </span>
<span class="sd">        prof = Profile([[3, 0, 1, 2], [1, 3, 2, 0], [1, 3, 0, 2], [1, 2, 0, 3], [3, 2, 0, 1], [0, 2, 1, 3]], [1, 1, 1, 1, 2, 1])</span>

<span class="sd">        minimax.display(prof)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>

    <span class="n">scores</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="nb">max</span><span class="p">([</span><span class="n">strength_function</span><span class="p">(</span><span class="n">_c</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">_c</span> <span class="ow">in</span> <span class="n">edata</span><span class="o">.</span><span class="n">dominators</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edata</span><span class="o">.</span><span class="n">dominators</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> 
              <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">}</span>
    <span class="n">min_score</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">scores</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_score</span><span class="p">])</span></div>

<div class="viewcode-block" id="minimax_scores"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.minimax_scores">[docs]</a><span class="k">def</span> <span class="nf">minimax_scores</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">score_method</span><span class="o">=</span><span class="s2">&quot;margins&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the minimax scores for each candidate, where the minimax score for :math:`c` is -1 * the maximum pairwise majority loss. </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        score_method (str, optional): Options include &quot;margins&quot; (the default), &quot;winning&quot; assings to each candidate :math:`c` the maximum support of a candidate majority preferred to :math:`c`,  and &quot;pairwise_opposition&quot; assings to each candidate :math:`c` the maximum support of any candidate over :math:`c`.   These scores only lead to different results on non-linear profiles. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A dictionary associating each candidate with its minimax score.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.minimax`</span>

<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_minimax.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. code-block:: </span>

<span class="sd">        from pref_voting.margin_based_methods import minimax_scores, minimax</span>

<span class="sd">        minimax.display(prof)</span>
<span class="sd">        print(minimax_scores(prof))</span>


<span class="sd">    .. exec_code:: </span>
<span class="sd">        :hide_code:</span>

<span class="sd">        from pref_voting.profiles import Profile</span>
<span class="sd">        from pref_voting.margin_based_methods import minimax, minimax_scores</span>
<span class="sd">        </span>
<span class="sd">        prof = Profile([[3, 0, 1, 2], [1, 3, 2, 0], [1, 3, 0, 2], [1, 2, 0, 3], [3, 2, 0, 1], [0, 2, 1, 3]], [1, 1, 1, 1, 2, 1])</span>

<span class="sd">        minimax.display(prof)</span>
<span class="sd">        print(minimax_scores(prof))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">}</span>
    
    <span class="c1"># there are different scoring functions that can be used to measure the worse loss for each </span>
    <span class="c1"># candidate. These all produce the same set of winners when voters submit linear orders. </span>
    <span class="n">score_functions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;winning&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">cs</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">max</span><span class="p">([</span><span class="n">edata</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="n">_c</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">_c</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;margins&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">cs</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">max</span><span class="p">([</span><span class="n">edata</span><span class="o">.</span><span class="n">margin</span><span class="p">(</span><span class="n">_c</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">_c</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;pairwise_opposition&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">cs</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">max</span><span class="p">([</span><span class="n">edata</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="n">_c</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">_c</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">])</span>
    <span class="p">}</span> 
    
    <span class="n">cands</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;winning&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">edata</span><span class="o">.</span><span class="n">dominators</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">),</span>
        <span class="s2">&quot;margins&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">edata</span><span class="o">.</span><span class="n">dominators</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">),</span>
        <span class="s2">&quot;pairwise_opposition&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="p">[</span><span class="n">_c</span> <span class="k">for</span> <span class="n">_c</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">_c</span> <span class="o">!=</span> <span class="n">c</span><span class="p">]</span>
    <span class="p">}</span> 

    <span class="k">return</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">score_functions</span><span class="p">[</span><span class="n">score_method</span><span class="p">](</span><span class="n">cands</span><span class="p">[</span><span class="n">score_method</span><span class="p">](</span><span class="n">c</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">}</span></div>


<span class="k">def</span> <span class="nf">maximal_elements</span><span class="p">(</span><span class="n">g</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;return the nodes in g with no incoming arrows.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>


<div class="viewcode-block" id="beat_path"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.beat_path">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Beat Path&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">beat_path</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;For candidates :math:`a` and :math:`b`, a **path** from :math:`a` to :math:`b` is a sequence </span>
<span class="sd">    :math:`x_1, \ldots, x_n` of distinct candidates  with  :math:`x_1=a` and :math:`x_n=b` such that </span>
<span class="sd">    for :math:`1\leq k\leq n-1`, :math:`x_k` is majority preferred to :math:`x_{k+1}`.  The **strength of a path**</span>
<span class="sd">    is the minimal margin along that path.  Say that :math:`a` defeats :math:`b` according to Beat Path if the the strength of the strongest path from :math:`a` to :math:`b` is greater than the strength of the strongest path from :math:`b` to :math:`a`. Then, the candidates that are undefeated according to Beat Path are the winners.  Also known as the Schulze Rule. </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.beat_path_faster`, :meth:`pref_voting.margin_based_methods.beat_path_defeat`</span>


<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_bp_rp.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. code-block:: </span>

<span class="sd">        from pref_voting.margin_based_methods import beat_path</span>

<span class="sd">        beat_path.display(mg)</span>


<span class="sd">    .. exec_code:: </span>
<span class="sd">        :hide_code:</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import beat_path</span>
<span class="sd">        </span>
<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 2, 3), (1, 0, 5), (2, 1, 5), (2, 3, 1), (3, 0, 3), (3, 1, 1)])</span>
<span class="sd">        </span>
<span class="sd">        beat_path.display(mg)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>
    
    <span class="n">mg</span> <span class="o">=</span> <span class="n">get_mg</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">)</span>
    
    <span class="n">beat_paths_weights</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="p">{</span><span class="n">c2</span><span class="p">:</span><span class="mi">0</span> <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">c2</span> <span class="o">!=</span> <span class="n">c</span><span class="p">}</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span> 
        <span class="k">for</span> <span class="n">other_c</span> <span class="ow">in</span> <span class="n">beat_paths_weights</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">all_paths</span> <span class="o">=</span>  <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">other_c</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_paths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">beat_paths_weights</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">other_c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">min</span><span class="p">([</span><span class="n">strength_function</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> 
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span> 
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_paths</span><span class="p">])</span>
    
    <span class="n">winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span> 
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">beat_paths_weights</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">c2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">beat_paths_weights</span><span class="p">[</span><span class="n">c2</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span>  <span class="k">if</span> <span class="n">c2</span> <span class="o">!=</span> <span class="n">c</span><span class="p">]):</span>
            <span class="n">winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">winners</span><span class="p">))</span></div>


<div class="viewcode-block" id="beat_path_faster"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.beat_path_faster">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Beat Path&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">beat_path_faster</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;An implementation of Beat Path using a variation of the Floyd Warshall-Algorithm</span>
<span class="sd">    See https://en.wikipedia.org/wiki/Schulze_method#Implementation)</span>
<span class="sd"> </span>
<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.beat_path`, :meth:`pref_voting.margin_based_methods.beat_path_defeat`</span>


<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_bp_rp.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. code-block:: </span>

<span class="sd">        from pref_voting.margin_based_methods import beat_path_faster</span>

<span class="sd">        beat_path.display(mg)</span>
<span class="sd">        beat_path_faster.display(mg)</span>


<span class="sd">    .. exec_code:: </span>
<span class="sd">        :hide_code:</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import beat_path, beat_path_faster</span>
<span class="sd">        </span>
<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 2, 3), (1, 0, 5), (2, 1, 5), (2, 3, 1), (3, 0, 3), (3, 1, 1)])</span>

<span class="sd">        beat_path.display(mg)</span>
<span class="sd">        beat_path_faster.display(mg)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>
        
    <span class="n">s_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">c1_idx</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c2_idx</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edata</span><span class="o">.</span><span class="n">majority_prefers</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="p">):</span>
                <span class="n">s_matrix</span><span class="p">[</span><span class="n">c1_idx</span><span class="p">][</span><span class="n">c2_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> 
    <span class="n">strength</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span> <span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">,</span> <span class="n">s_matrix</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i_idx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>         
        <span class="k">for</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span> 
            <span class="k">if</span> <span class="n">i</span><span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k_idx</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span> 
                    <span class="k">if</span> <span class="n">i</span><span class="o">!=</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                        <span class="n">strength</span><span class="p">[</span><span class="n">j_idx</span><span class="p">][</span><span class="n">k_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">strength</span><span class="p">[</span><span class="n">j_idx</span><span class="p">][</span><span class="n">k_idx</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">strength</span><span class="p">[</span><span class="n">j_idx</span><span class="p">][</span><span class="n">i_idx</span><span class="p">],</span><span class="n">strength</span><span class="p">[</span><span class="n">i_idx</span><span class="p">][</span><span class="n">k_idx</span><span class="p">]))</span>
    <span class="n">winners</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="kc">True</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">i_idx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span> 
        <span class="k">for</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">strength</span><span class="p">[</span><span class="n">j_idx</span><span class="p">][</span><span class="n">i_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">strength</span><span class="p">[</span><span class="n">i_idx</span><span class="p">][</span><span class="n">j_idx</span><span class="p">]:</span>
                    <span class="n">winners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">winners</span><span class="p">[</span><span class="n">c</span><span class="p">]])</span></div>

<div class="viewcode-block" id="beat_path_defeat"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.beat_path_defeat">[docs]</a><span class="k">def</span> <span class="nf">beat_path_defeat</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;Returns the defeat relation for Beat Path. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A networkx DiGraph representing the Beat Path defeat relation. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.beat_path`, :meth:`pref_voting.margin_based_methods.beat_path_faster`</span>

<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_bp_defeat.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">defeat</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>
    
    <span class="n">mg</span> <span class="o">=</span> <span class="n">get_mg</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">)</span>
    
    <span class="n">beat_paths_weights</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="p">{</span><span class="n">c2</span><span class="p">:</span><span class="mi">0</span> <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">c2</span> <span class="o">!=</span> <span class="n">c</span><span class="p">}</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span> 
        <span class="k">for</span> <span class="n">other_c</span> <span class="ow">in</span> <span class="n">beat_paths_weights</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">all_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">other_c</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_paths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">beat_paths_weights</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">other_c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">min</span><span class="p">([</span><span class="n">strength_function</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_paths</span><span class="p">])</span>
        
    <span class="n">defeat</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span> 
        <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span><span class="p">:</span> 
                <span class="k">if</span> <span class="n">beat_paths_weights</span><span class="p">[</span><span class="n">c1</span><span class="p">][</span><span class="n">c2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">beat_paths_weights</span><span class="p">[</span><span class="n">c2</span><span class="p">][</span><span class="n">c1</span><span class="p">]:</span> 
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span>

    <span class="n">defeat</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">defeat</span></div>
    
<div class="viewcode-block" id="split_cycle"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.split_cycle">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Split Cycle&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">split_cycle</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A **majority cycle** is a sequence :math:`x_1, \ldots ,x_n` of distinct candidates with :math:`x_1=x_n` such that for :math:`1 \leq k \leq n-1`,  :math:`x_k` is majority preferred to :math:`x_{k+1}`.  The Split Cycle winners are determined as follows:  </span>
<span class="sd">    </span>
<span class="sd">    1. In each cycle, identify the head-to-head win(s) with the smallest margin of victory in that cycle.</span>
<span class="sd">    2. After completing step 1 for all cycles, discard the identified wins. All remaining wins count as defeats of the losing candidates.</span>

<span class="sd">    The candidates that are undefeated are the Split Cycle winners. </span>

<span class="sd">    See https://github.com/epacuit/splitcycle and the paper https://arxiv.org/abs/2004.02350 for more information. </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.split_cycle_faster`, :meth:`pref_voting.margin_based_methods.split_cycle_defeat`</span>


<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_bp_rp.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. code-block:: </span>

<span class="sd">        from pref_voting.margin_based_methods import split_cycle</span>

<span class="sd">        split_cycle.display(mg)</span>


<span class="sd">    .. exec_code:: </span>
<span class="sd">        :hide_code:</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import split_cycle</span>
<span class="sd">        </span>
<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 2, 3), (1, 0, 5), (2, 1, 5), (2, 3, 1), (3, 0, 3), (3, 1, 1)])</span>
<span class="sd">        </span>
<span class="sd">        split_cycle.display(mg)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span> 
    
    <span class="c1"># create the majority graph</span>
    <span class="n">mg</span> <span class="o">=</span> <span class="n">get_mg</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">)</span> 
    
    <span class="c1"># find the cycle number for each candidate</span>
    <span class="n">cycle_number</span> <span class="o">=</span> <span class="p">{</span><span class="n">cs</span><span class="p">:</span><span class="mi">0</span> <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span><span class="mi">2</span><span class="p">)}</span>
    <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="n">mg</span><span class="p">):</span> <span class="c1"># for each cycle in the margin graph</span>
        
        <span class="c1"># get all the margins (i.e., the weights) of the edges in the cycle</span>
        <span class="n">strengths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> 
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cycle</span><span class="p">):</span> 
            <span class="n">next_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="n">next_idx</span><span class="p">]</span>
            <span class="n">strengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span>
            
        <span class="n">split_number</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">strengths</span><span class="p">)</span> <span class="c1"># the split number of the cycle is the minimal margin</span>
        
        <span class="k">for</span> <span class="n">c1</span><span class="p">,</span><span class="n">c2</span> <span class="ow">in</span> <span class="n">cycle_number</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">c1_index</span> <span class="o">=</span> <span class="n">cycle</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="k">if</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">cycle</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">c2_index</span> <span class="o">=</span> <span class="n">cycle</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="k">if</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">cycle</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># only need to check cycles with an edge from c1 to c2</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c1_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">c2_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">c2_index</span> <span class="o">==</span> <span class="n">c1_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">c1_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">c2_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="n">cycle_number</span><span class="p">[(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">split_number</span> <span class="k">if</span> <span class="n">split_number</span> <span class="o">&gt;</span> <span class="n">cycle_number</span><span class="p">[(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)]</span> <span class="k">else</span> <span class="n">cycle_number</span><span class="p">[(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)]</span>        
    
    <span class="c1"># construct the defeat relation, where a defeats b if margin(a,b) &gt; cycle_number(a,b) (see Lemma 3.13)</span>
    <span class="n">defeat</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">defeat</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
    <span class="n">defeat</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)</span>  
           <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">candidates</span> 
           <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span> <span class="k">if</span> <span class="n">edata</span><span class="o">.</span><span class="n">majority_prefers</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cycle_number</span><span class="p">[(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)]])</span>
   
    <span class="c1"># the winners are candidates not defeated by any other candidate</span>
    <span class="n">winners</span> <span class="o">=</span> <span class="n">maximal_elements</span><span class="p">(</span><span class="n">defeat</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">winners</span><span class="p">)))</span></div>


<div class="viewcode-block" id="split_cycle_faster"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.split_cycle_faster">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Split Cycle&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">split_cycle_faster</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;An implementation of Split Cycle based on the Floyd-Warshall Algorithm. </span>

<span class="sd">    See https://github.com/epacuit/splitcycle and the paper https://arxiv.org/abs/2004.02350 for more information. </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.split_cycle`, :meth:`pref_voting.margin_based_methods.split_cycle_defeat`</span>


<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_bp_rp.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. code-block:: </span>

<span class="sd">        from pref_voting.margin_based_methods import split_cycle, split_cycle_faster</span>

<span class="sd">        split_cycle.display(mg)</span>
<span class="sd">        split_cycle_faster.display(mg)</span>


<span class="sd">    .. exec_code:: </span>
<span class="sd">        :hide_code:</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import split_cycle, split_cycle_faster</span>
<span class="sd">        </span>
<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 2, 3), (1, 0, 5), (2, 1, 5), (2, 3, 1), (3, 0, 3), (3, 1, 1)])</span>
<span class="sd">        </span>
<span class="sd">        split_cycle.display(mg)</span>
<span class="sd">        split_cycle_faster.display(mg)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span> 
 
    <span class="n">weak_condorcet_winners</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span><span class="kc">True</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">}</span>
    <span class="n">s_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
    
    <span class="c1"># Weak Condorcet winners are Split Cycle winners</span>
    <span class="k">for</span> <span class="n">c1_idx</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c2_idx</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edata</span><span class="o">.</span><span class="n">majority_prefers</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="p">):</span>
                <span class="n">s_matrix</span><span class="p">[</span><span class="n">c1_idx</span><span class="p">][</span><span class="n">c2_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> 
                <span class="n">weak_condorcet_winners</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="o">=</span> <span class="n">weak_condorcet_winners</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="p">)</span>
    
    <span class="n">strength</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span> <span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">,</span> <span class="n">s_matrix</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i_idx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span> 
        <span class="k">for</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">weak_condorcet_winners</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> <span class="c1"># weak Condorcet winners are Split Cycle winners</span>
                    <span class="k">for</span> <span class="n">k_idx</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span> 
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                            <span class="n">strength</span><span class="p">[</span><span class="n">j_idx</span><span class="p">][</span><span class="n">k_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">strength</span><span class="p">[</span><span class="n">j_idx</span><span class="p">][</span><span class="n">k_idx</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">strength</span><span class="p">[</span><span class="n">j_idx</span><span class="p">][</span><span class="n">i_idx</span><span class="p">],</span><span class="n">strength</span><span class="p">[</span><span class="n">i_idx</span><span class="p">][</span><span class="n">k_idx</span><span class="p">]))</span>
    <span class="n">winners</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="kc">True</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">i_idx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s_matrix</span><span class="p">[</span><span class="n">j_idx</span><span class="p">][</span><span class="n">i_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">strength</span><span class="p">[</span><span class="n">i_idx</span><span class="p">][</span><span class="n">j_idx</span><span class="p">]:</span> <span class="c1"># the main difference with Beat Path</span>
                    <span class="n">winners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">winners</span><span class="p">[</span><span class="n">c</span><span class="p">]])</span></div>


<div class="viewcode-block" id="split_cycle_defeat"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.split_cycle_defeat">[docs]</a><span class="k">def</span> <span class="nf">split_cycle_defeat</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the Split Cycle defeat relation. </span>

<span class="sd">    See https://arxiv.org/abs/2008.08451 for an extended discussion of this notion of defeat in an election. </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A networkx DiGraph representing the Beat Path defeat relation. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.split_cycle`, :meth:`pref_voting.margin_based_methods.split_cycle_faster`</span>

<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_sc_defeat.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>
    
    <span class="c1"># create the margin graph</span>
    <span class="n">mg</span> <span class="o">=</span> <span class="n">get_mg</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">)</span>
    
    <span class="c1"># find the cycle number for each candidate</span>
    <span class="n">cycle_number</span> <span class="o">=</span> <span class="p">{</span><span class="n">cs</span><span class="p">:</span><span class="mi">0</span> <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span><span class="mi">2</span><span class="p">)}</span>
    <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="n">mg</span><span class="p">):</span> <span class="c1"># for each cycle in the margin graph</span>

        <span class="c1"># get all the margins (i.e., the weights) of the edges in the cycle</span>
        <span class="n">margins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> 
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cycle</span><span class="p">):</span> 
            <span class="n">next_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="n">next_idx</span><span class="p">]</span>
            <span class="n">margins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edata</span><span class="o">.</span><span class="n">margin</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span>
            
        <span class="n">split_number</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">margins</span><span class="p">)</span> <span class="c1"># the split number of the cycle is the minimal margin</span>
        <span class="k">for</span> <span class="n">c1</span><span class="p">,</span><span class="n">c2</span> <span class="ow">in</span> <span class="n">cycle_number</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">c1_index</span> <span class="o">=</span> <span class="n">cycle</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="k">if</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">cycle</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">c2_index</span> <span class="o">=</span> <span class="n">cycle</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="k">if</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">cycle</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># only need to check cycles with an edge from c1 to c2</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c1_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">c2_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">c2_index</span> <span class="o">==</span> <span class="n">c1_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">c1_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">c2_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="n">cycle_number</span><span class="p">[(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">split_number</span> <span class="k">if</span> <span class="n">split_number</span> <span class="o">&gt;</span> <span class="n">cycle_number</span><span class="p">[(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)]</span> <span class="k">else</span> <span class="n">cycle_number</span><span class="p">[(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)]</span>        

    <span class="c1"># construct the defeat relation, where a defeats b if margin(a,b) &gt; cycle_number(a,b) (see Lemma 3.13)</span>
    <span class="n">defeat</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">defeat</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
    <span class="n">defeat</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span>  
           <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">candidates</span> 
           <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span> <span class="k">if</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cycle_number</span><span class="p">[(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)]])</span>

    <span class="k">return</span> <span class="n">defeat</span></div>



<span class="c1"># flatten a 2d list - turn a 2d list into a single list of items</span>
<span class="n">flatten</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">does_create_cycle</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;return True if adding the edge to g create a cycle.</span>
<span class="sd">    it is assumed that edge is already in g&#39;&#39;&#39;</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">has_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span> 
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="ranked_pairs"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.ranked_pairs">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ranked Pairs&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ranked_pairs</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Order the edges in the margin graph from largest to smallest and lock them in in that order, skipping edges that create a cycle.  If there are ties in the margins, break the ties using a tie-breaking rule: a linear ordering over the edges.   A candidate is a Ranked Pairs winner if it wins according to some tie-breaking rule. Also known as Tideman&#39;s Rule.</span>

<span class="sd">    .. warning:: </span>
<span class="sd">        This method can take a very long time to find winners. </span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.ranked_pairs_with_test`, :meth:`pref_voting.margin_based_methods.ranked_pairs_zt`, :meth:`pref_voting.margin_based_methods.ranked_pairs_defeats`</span>

<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_bp_rp.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. code-block:: </span>

<span class="sd">        from pref_voting.margin_based_methods import ranked_pairs</span>

<span class="sd">        ranked_pairs.display(mg)</span>


<span class="sd">    .. exec_code:: </span>
<span class="sd">        :hide_code:</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import ranked_pairs</span>
<span class="sd">        </span>
<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 2, 3), (1, 0, 5), (2, 1, 5), (2, 3, 1), (3, 0, 3), (3, 1, 1)])</span>
<span class="sd">        </span>
<span class="sd">        ranked_pairs.display(mg)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>    

    <span class="n">cw</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">condorcet_winner</span><span class="p">()</span>
    <span class="c1"># Ranked Pairs is Condorcet consistent, so simply return the Condorcet winner if exists</span>
    <span class="k">if</span> <span class="n">cw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">winners</span> <span class="o">=</span> <span class="p">[</span><span class="n">cw</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> 
                   <span class="k">if</span> <span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edata</span><span class="o">.</span><span class="n">majority_prefers</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">edata</span><span class="o">.</span><span class="n">is_tied</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))]</span>
        <span class="n">winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>   
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>          
            <span class="n">strengths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span><span class="p">])),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sorted_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strengths</span><span class="p">]</span>
            <span class="n">tbs</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">permutations</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">sorted_edges</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">tb</span> <span class="ow">in</span> <span class="n">tbs</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
                <span class="n">rp_defeat</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span> 
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> 
                    <span class="n">rp_defeat</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">does_create_cycle</span><span class="p">(</span><span class="n">rp_defeat</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                        <span class="n">rp_defeat</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maximal_elements</span><span class="p">(</span><span class="n">rp_defeat</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">winners</span> <span class="o">=</span> <span class="n">candidates</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">winners</span><span class="p">)))</span></div>

<div class="viewcode-block" id="ranked_pairs_with_test"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.ranked_pairs_with_test">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ranked Pairs&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ranked_pairs_with_test</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;Find the Ranked Pairs winners, but include a test to determined if it will take too long to compute the Ranked Pairs winners. If the calculation of the winners will take too long, return None.</span>

<span class="sd">    .. important::</span>
<span class="sd">        This voting method that might return None rather than a list of candidates.  </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.ranked_pairs_with_test`, :meth:`pref_voting.margin_based_methods.ranked_pairs_zt`, :meth:`pref_voting.margin_based_methods.ranked_pairs_defeats`</span>

<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_rp_with_test.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. code-block:: </span>

<span class="sd">        from pref_voting.margin_based_methods import ranked_pairs_with_test</span>

<span class="sd">        ranked_pairs_with_test.display(mg)</span>


<span class="sd">    .. exec_code:: </span>
<span class="sd">        :hide_code:</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import ranked_pairs_with_test</span>
<span class="sd">        </span>
<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(1, 2, 2), (1, 3, 2), (2, 0, 2)])</span>
<span class="sd">        </span>
<span class="sd">        ranked_pairs_with_test.display(mg)</span>


<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>   

    <span class="n">cw</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">condorcet_winner</span><span class="p">()</span>
    <span class="c1"># Ranked Pairs is Condorcet consistent, so simply return the Condorcet winner if exists</span>
    <span class="k">if</span> <span class="n">cw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">winners</span> <span class="o">=</span> <span class="p">[</span><span class="n">cw</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> 
                   <span class="k">if</span> <span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edata</span><span class="o">.</span><span class="n">majority_prefers</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">edata</span><span class="o">.</span><span class="n">is_tied</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))]</span>
        <span class="n">winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>            
        <span class="n">strengths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span><span class="p">])),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sorted_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strengths</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">es</span><span class="p">))</span> <span class="k">for</span> <span class="n">es</span> <span class="ow">in</span> <span class="n">sorted_edges</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">3000</span><span class="p">:</span> 
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">tbs</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">permutations</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">sorted_edges</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">tb</span> <span class="ow">in</span> <span class="n">tbs</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
                <span class="n">rp_defeat</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span> 
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> 
                    <span class="n">rp_defeat</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">does_create_cycle</span><span class="p">(</span><span class="n">rp_defeat</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                        <span class="n">rp_defeat</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maximal_elements</span><span class="p">(</span><span class="n">rp_defeat</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">winners</span><span class="p">)))</span></div>

<div class="viewcode-block" id="ranked_pairs_defeats"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.ranked_pairs_defeats">[docs]</a><span class="k">def</span> <span class="nf">ranked_pairs_defeats</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the Ranked Pairs defeat relations produced by the Ranked Pairs algorithm. </span>

<span class="sd">    .. important::</span>
<span class="sd">        Unlike the other functions that return a single defeat relation, this returns a list of defeat relations. </span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A networkx DiGraph representing the Beat Path defeat relation. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.ranked_pairs`, :meth:`pref_voting.margin_based_methods.ranked_pairs_with_test`</span>

<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_rp_defeats.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>

<span class="sd">    .. exec_code::</span>


<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import ranked_pairs_defeats</span>

<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 1, 10), (0, 2, 2), (1, 3, 4), (2, 1, 6), (2, 3, 8), (3, 0, 4)])</span>
<span class="sd">        rp_defeats = ranked_pairs_defeats(mg)</span>

<span class="sd">        for rpd in rp_defeats: </span>
<span class="sd">            print(rpd.edges)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>    

    <span class="n">w_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edata</span><span class="o">.</span><span class="n">majority_prefers</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">edata</span><span class="o">.</span><span class="n">is_tied</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))]</span>
    <span class="n">winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>            
    <span class="n">strengths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span><span class="p">])),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sorted_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strengths</span><span class="p">]</span>
    <span class="n">tbs</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">permutations</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">sorted_edges</span><span class="p">])</span>
    <span class="n">rp_defeats</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">tb</span> <span class="ow">in</span> <span class="n">tbs</span><span class="p">:</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
        <span class="n">rp_defeat</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span> 
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> 
            <span class="n">rp_defeat</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">does_create_cycle</span><span class="p">(</span><span class="n">rp_defeat</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                <span class="n">rp_defeat</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rp_defeats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rp_defeat</span><span class="p">)</span>
        <span class="n">winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maximal_elements</span><span class="p">(</span><span class="n">rp_defeat</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">rp_defeats</span></div>

<span class="k">def</span> <span class="nf">powerset</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the powerset of ``iterable``</span>

<span class="sd">    powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>


<div class="viewcode-block" id="is_stack"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.is_stack">[docs]</a><span class="k">def</span> <span class="nf">is_stack</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">cand_list</span><span class="p">,</span> <span class="n">curr_cands</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A **stack** is a linear order :math:`L` on the candidate such that for all candidates :math:`a` and :math:`b`, if :math:`aLb`, then there are distinct candidates :math:`x_1,\dots,x_n` with :math:`x_1=a` and :math:`x_n=b` such that :math:`x_i L x_{i+1}` and for all :math:`i\in \{1,\dots, n-1\}`, the margin of :math:`x_1` over :math:`x_{i+1}` is greater than or equal to the margin of :math:`b` over :math:`a`.</span>

<span class="sd">    This definition is due to Zavist and Tideman 1989, and is used as an alternative characterization of Ranked Pairs: :math:`a` is a Ranked Pairs winner if and only if :math:`a` is the maximum element of some stack. </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        cand_list (list): The list of candidates that may be a stack</span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>

<span class="sd">    Returns: </span>
<span class="sd">        True if ``cand_list`` is a stack and False otherwise</span>

<span class="sd">    :Example: </span>
<span class="sd">    </span>
<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_rp_stacks.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. exec_code::</span>
<span class="sd">        </span>
<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import is_stack</span>
<span class="sd">        from itertools import permutations</span>
<span class="sd">        </span>
<span class="sd">        mg = MarginGraph([0, 1, 2], [(0, 1, 2), (1, 2, 4), (2, 0, 2)])</span>
<span class="sd">        </span>
<span class="sd">        for clist in permutations(mg.candidates): </span>
<span class="sd">            print(f&quot;{clist} {&#39;is&#39; if is_stack(mg, clist) else &#39;is not&#39;} a stack&quot;)</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span>
    <span class="n">cand_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">if</span> <span class="n">cand_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cand_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
        
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">cand_pairs</span><span class="p">:</span>
        <span class="n">other_cands</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">b</span><span class="p">]</span>
        <span class="n">found_path</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="n">sublist</span> <span class="o">=</span> <span class="n">cand_list</span><span class="p">[</span><span class="n">cand_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">cand_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span>
        
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">powerset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">))):</span> 
            
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">sublist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">margins</span> <span class="o">=</span> <span class="p">[</span><span class="n">edata</span><span class="o">.</span><span class="n">margin</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">cand_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cand_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">margins</span><span class="p">]):</span> 
                <span class="n">found_path</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_path</span><span class="p">:</span> 
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="ranked_pairs_from_stacks"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.ranked_pairs_from_stacks">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ranked Pairs&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ranked_pairs_from_stacks</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;Find the Ranked Pairs winners by iterating over all permutations of candidates (restricted to ``curr_cands`` if not None), and checking if the list is a stack. </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.ranked_pairs`, :meth:`pref_voting.margin_based_methods.is_stack`</span>

<span class="sd">    :Example: </span>

<span class="sd">    .. plot::  margin_graphs_examples/mg_ex_bp_rp.py</span>
<span class="sd">        :context: reset  </span>
<span class="sd">        :include-source: True</span>


<span class="sd">    .. code-block:: </span>

<span class="sd">        from pref_voting.margin_based_methods import ranked_pairs, ranked_pairs_from_stacks</span>

<span class="sd">        ranked_pairs.display(mg)</span>
<span class="sd">        ranked_pairs_from_stacks.display(mg)</span>


<span class="sd">    .. exec_code:: </span>
<span class="sd">        :hide_code:</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import ranked_pairs, ranked_pairs_from_stacks</span>
<span class="sd">        </span>
<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 2, 3), (1, 0, 5), (2, 1, 5), (2, 3, 1), (3, 0, 3), (3, 1, 1)])</span>

<span class="sd">        ranked_pairs.display(mg)</span>
<span class="sd">        ranked_pairs_from_stacks.display(mg)</span>

<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="n">candidates</span> <span class="o">=</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span>
    <span class="n">winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">clist</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span> 
        <span class="n">isstack</span> <span class="o">=</span> <span class="n">is_stack</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isstack</span><span class="p">:</span> 
            <span class="n">winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">winners</span><span class="p">)))</span></div>

<div class="viewcode-block" id="ranked_pairs_tb"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.ranked_pairs_tb">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ranked Pairs T&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ranked_pairs_tb</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tie_breaker</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ranked Pairs with a fixed linear order on the candidates to break any ties in the margins.   </span>
<span class="sd">    Since the tie_breaker is a linear order, this method is resolute.   </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.ranked_pairs`, :meth:`pref_voting.margin_based_methods.ranked_pairs_with_test`, :meth:`pref_voting.margin_based_methods.ranked_pairs_from_stacks`</span>

<span class="sd">    .. exec_code::</span>

<span class="sd">        from pref_voting.profiles import Profile</span>
<span class="sd">        from pref_voting.margin_based_methods import ranked_pairs_from_stacks, ranked_pairs_tb, ranked_pairs_zt</span>

<span class="sd">        prof = Profile([[2, 3, 1, 0], [0, 3, 1, 2], [1, 3, 2, 0], [2, 1, 3, 0]], [1, 1, 1, 1])</span>

<span class="sd">        prof.display()</span>

<span class="sd">        ranked_pairs_from_stacks.display(prof)</span>
<span class="sd">        ranked_pairs_tb.display(prof)</span>
<span class="sd">        ranked_pairs_tb.display(prof, tie_breaker = [3, 2, 1, 0])</span>
<span class="sd">        ranked_pairs_zt.display(prof)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>
    
    <span class="n">tb_ranking</span> <span class="o">=</span> <span class="n">tie_breaker</span> <span class="k">if</span> <span class="n">tie_breaker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">candidates</span><span class="p">))</span>

    <span class="n">cw</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">condorcet_winner</span><span class="p">()</span>
    <span class="c1"># Ranked Pairs is Condorcet consistent, so simply return the Condorcet winner if exists</span>
    <span class="k">if</span> <span class="n">cw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">winners</span> <span class="o">=</span> <span class="p">[</span><span class="n">cw</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> 
                   <span class="k">if</span> <span class="n">edata</span><span class="o">.</span><span class="n">majority_prefers</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">edata</span><span class="o">.</span><span class="n">is_tied</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)]</span>
        <span class="n">winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>            
        <span class="n">strengths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span><span class="p">])),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">rp_defeat</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span> 
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strengths</span><span class="p">:</span> 
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">]</span>
            
            <span class="c1"># break ties using the lexicographic ordering on tuples given tb_ranking</span>
            <span class="n">sorted_edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">tb_ranking</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">tb_ranking</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sorted_edges</span><span class="p">:</span> 
                <span class="n">rp_defeat</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">does_create_cycle</span><span class="p">(</span><span class="n">rp_defeat</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                    <span class="n">rp_defeat</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maximal_elements</span><span class="p">(</span><span class="n">rp_defeat</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">winners</span><span class="p">)))</span></div>


<div class="viewcode-block" id="ranked_pairs_zt"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.ranked_pairs_zt">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ranked Pairs ZT&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ranked_pairs_zt</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;Ranked pairs where a fixed voter breaks any ties in the margins.  It is always the voter in position 0 that breaks the ties.  Since voters have strict preferences, this method is resolute.  This is known as Ranked Pairs ZT, for Zavist Tideman.</span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile): A profile of linear orders</span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.ranked_pairs`, :meth:`pref_voting.margin_based_methods.ranked_pairs_with_test`, :meth:`pref_voting.margin_based_methods.ranked_pairs_from_stacks`</span>

<span class="sd">    .. exec_code::</span>

<span class="sd">        from pref_voting.profiles import Profile</span>
<span class="sd">        from pref_voting.margin_based_methods import ranked_pairs_from_stacks, ranked_pairs_tb, ranked_pairs_zt</span>

<span class="sd">        prof = Profile([[2, 3, 1, 0], [0, 3, 1, 2], [1, 3, 2, 0], [2, 1, 3, 0]], [1, 1, 1, 1])</span>

<span class="sd">        prof.display()</span>

<span class="sd">        ranked_pairs_from_stacks.display(prof)</span>
<span class="sd">        ranked_pairs_tb.display(prof)</span>
<span class="sd">        ranked_pairs_tb.display(prof, tie_breaker = [3, 2, 1, 0])</span>
<span class="sd">        ranked_pairs_zt.display(prof)</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    
    <span class="c1"># the tie-breaker is always the first voter. </span>
    <span class="n">tb_ranking</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">_rankings</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">ranked_pairs_tb</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">,</span> <span class="n">tie_breaker</span> <span class="o">=</span> <span class="n">tb_ranking</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="n">strength_function</span><span class="p">)</span></div>



<div class="viewcode-block" id="river"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.river">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;River&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">river</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Order the edges in the weak margin graph from largest to smallest and lock them in in that order, skipping edges that create a cycle *and edges in which there is already an edge pointing to the target*.  Break ties using a tie-breaking  linear ordering over the edges.  A candidate is a River winner if it wins according to some tie-breaking rule. See https://electowiki.org/wiki/River.</span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    :Example: </span>

<span class="sd">    .. exec_code:: </span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import river, ranked_pairs</span>
<span class="sd">        </span>
<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 2, 2), (0, 3, 8), (1, 0, 12), (2, 3, 12), (3, 1, 6)])</span>

<span class="sd">        ranked_pairs.display(mg)</span>
<span class="sd">        river.display(mg)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>    

    <span class="n">cw</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">condorcet_winner</span><span class="p">()</span>
    <span class="c1"># Ranked Pairs is Condorcet consistent, so simply return the Condorcet winner if exists</span>
    <span class="k">if</span> <span class="n">cw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">winners</span> <span class="o">=</span> <span class="p">[</span><span class="n">cw</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> 
                   <span class="k">if</span> <span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edata</span><span class="o">.</span><span class="n">majority_prefers</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">edata</span><span class="o">.</span><span class="n">is_tied</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))]</span>
        <span class="n">winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>            
        <span class="n">strengths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span><span class="p">])),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sorted_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strengths</span><span class="p">]</span>
        <span class="n">tbs</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">permutations</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">sorted_edges</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">tb</span> <span class="ow">in</span> <span class="n">tbs</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
            <span class="n">river_defeat</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span> 
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> 
                <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">river_defeat</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">river_defeat</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">river_defeat</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">does_create_cycle</span><span class="p">(</span><span class="n">river_defeat</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                        <span class="n">river_defeat</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maximal_elements</span><span class="p">(</span><span class="n">river_defeat</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">winners</span><span class="p">)))</span></div>


<div class="viewcode-block" id="river_with_test"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.river_with_test">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;River&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">river_with_test</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>   
    <span class="sd">&quot;&quot;&quot;Find the River winners with a test to determined if it will take too long to compute the River winners. If the calculation of the winners will take too long, return None. </span>
<span class="sd">        </span>
<span class="sd">    .. important::</span>
<span class="sd">        This voting method that might return None rather than a list of candidates.  </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.ranked_pairs_with_test`, :meth:`pref_voting.margin_based_methods.river`</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> <span class="k">if</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr_cands</span>    
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>    

    <span class="n">cw</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">condorcet_winner</span><span class="p">()</span>
    <span class="c1"># Ranked Pairs is Condorcet consistent, so simply return the Condorcet winner if exists</span>
    <span class="k">if</span> <span class="n">cw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">winners</span> <span class="o">=</span> <span class="p">[</span><span class="n">cw</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">candidates</span> 
                   <span class="k">if</span> <span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edata</span><span class="o">.</span><span class="n">majority_prefers</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">edata</span><span class="o">.</span><span class="n">is_tied</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))]</span>
        <span class="n">winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>            
        <span class="n">strengths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span><span class="p">])),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sorted_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w_edges</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strengths</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">es</span><span class="p">))</span> <span class="k">for</span> <span class="n">es</span> <span class="ow">in</span> <span class="n">sorted_edges</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">3000</span><span class="p">:</span> 
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">tbs</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">permutations</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">sorted_edges</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">tb</span> <span class="ow">in</span> <span class="n">tbs</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
                <span class="n">river_defeat</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span> 
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> 
                    <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">river_defeat</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">river_defeat</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">river_defeat</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">does_create_cycle</span><span class="p">(</span><span class="n">river_defeat</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                            <span class="n">river_defeat</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maximal_elements</span><span class="p">(</span><span class="n">river_defeat</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">winners</span><span class="p">)))</span></div>

<span class="c1"># Simple Stable Voting </span>
<span class="k">def</span> <span class="nf">_simple_stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Determine the Simple Stable Voting winners while keeping track </span>
<span class="sd">    of the winners in any subprofiles checked during computation. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># curr_cands is the set of candidates who have not been removed</span>
    <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span> 
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>  
    
    <span class="n">sv_winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="n">matches</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">curr_cands</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">]</span>
    <span class="n">strengths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">strength_function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]))</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_cands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="n">mem_sv_winners</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">curr_cands</span><span class="p">)]</span> <span class="o">=</span> <span class="n">curr_cands</span>
        <span class="k">return</span> <span class="n">curr_cands</span><span class="p">,</span> <span class="n">mem_sv_winners</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">strengths</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ab_match</span> <span class="k">for</span> <span class="n">ab_match</span> <span class="ow">in</span> <span class="n">matches</span> 
                     <span class="k">if</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">ab_match</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab_match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sv_winners</span><span class="p">:</span> 
                <span class="n">cands_minus_b</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="n">c</span><span class="o">!=</span> <span class="n">b</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cands_minus_b</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mem_sv_winners</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> 
                    <span class="n">ws</span><span class="p">,</span> <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="n">_simple_stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> 
                                                               <span class="n">curr_cands</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">b</span><span class="p">],</span>
                                                               <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="n">mem_sv_winners</span><span class="p">,</span>
                                                               <span class="n">strength_function</span> <span class="o">=</span> <span class="n">strength_function</span><span class="p">)</span>
                    <span class="n">mem_sv_winners</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cands_minus_b</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ws</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">ws</span> <span class="o">=</span> <span class="n">mem_sv_winners</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cands_minus_b</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ws</span><span class="p">:</span>
                    <span class="n">sv_winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sv_winners</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sv_winners</span><span class="p">),</span> <span class="n">mem_sv_winners</span>

          
<div class="viewcode-block" id="simple_stable_voting"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.simple_stable_voting">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Simple Stable Voting&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">simple_stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;Implementation of  Simple Stable Voting from https://arxiv.org/abs/2108.00542. </span>

<span class="sd">    Simple Stable Voting is a recursive voting method defined as follows: </span>

<span class="sd">    1.  If there is only one candidate in the profile, then that candidate is the winner. </span>
<span class="sd">    2. Order the pairs :math:`(a,b)` of candidates from largest to smallest value of the margin of :math:`a` over :math:`b`, and declare as Simple Stable Voting winners the candidate(s) :math:`a` from the earliest pair(s) :math:`(a,b)` such that :math:`a` is a Simple Stable Voting winner in the election without :math:`b`. </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.simple_stable_voting_faster`, :meth:`pref_voting.margin_based_methods.stable_voting`</span>


<span class="sd">    :Example: </span>

<span class="sd">    .. exec_code::</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import simple_stable_voting</span>

<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 3, 8), (1, 0, 10), (2, 0, 4), (2, 1, 8), (3, 1, 8)])</span>

<span class="sd">        simple_stable_voting.display(mg)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">_simple_stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">,</span> <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="n">strength_function</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="simple_stable_voting_faster"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.simple_stable_voting_faster">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Simple Stable Voting&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">simple_stable_voting_faster</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;Simple Stable Voting is Condorcet consistent.   It is faster to skip executing the recursive algorithm when there is a Condorcet winnerFirst check if there is a Condorcet winner.  If so, return the Condorcet winner, otherwise find the Simple Stable Voting winnner using _simple_stable_voting</span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.simple_stable_voting`, :meth:`pref_voting.margin_based_methods.stable_voting`</span>


<span class="sd">    :Example: </span>

<span class="sd">    .. exec_code::</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import simple_stable_voting, simple_stable_voting_faster</span>

<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 3, 8), (1, 0, 10), (2, 0, 4), (2, 1, 8), (3, 1, 8)])</span>

<span class="sd">        simple_stable_voting_faster.display(mg)</span>
<span class="sd">        simple_stable_voting.display(mg)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">cw</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">condorcet_winner</span><span class="p">(</span><span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="k">return</span> <span class="p">[</span><span class="n">cw</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">_simple_stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">,</span> <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="n">strength_function</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

    
<span class="k">def</span> <span class="nf">_stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Determine the Stable Voting winners for the profile while keeping track of the winners in any subprofiles checked during computation. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># curr_cands is the set of candidates who have not been removed</span>
    <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_cands</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">edata</span><span class="o">.</span><span class="n">candidates</span>
    <span class="n">strength_function</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">margin</span> <span class="k">if</span> <span class="n">strength_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">strength_function</span>  

    <span class="n">sv_winners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    
    <span class="n">undefeated_candidates</span> <span class="o">=</span> <span class="n">split_cycle_faster</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">)</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">curr_cands</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">undefeated_candidates</span><span class="p">]</span>
    <span class="n">strengths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">strength_function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]))</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_cands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="n">mem_sv_winners</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">curr_cands</span><span class="p">)]</span> <span class="o">=</span> <span class="n">curr_cands</span>
        <span class="k">return</span> <span class="n">curr_cands</span><span class="p">,</span> <span class="n">mem_sv_winners</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">strengths</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ab_match</span> <span class="k">for</span> <span class="n">ab_match</span> <span class="ow">in</span> <span class="n">matches</span> 
                     <span class="k">if</span> <span class="n">strength_function</span><span class="p">(</span><span class="n">ab_match</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab_match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="o">==</span> <span class="n">s</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sv_winners</span><span class="p">:</span> 
                <span class="n">cands_minus_b</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="n">c</span><span class="o">!=</span> <span class="n">b</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cands_minus_b</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mem_sv_winners</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> 
                    <span class="n">ws</span><span class="p">,</span> <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="n">_stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curr_cands</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">b</span><span class="p">],</span> <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="n">mem_sv_winners</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="n">strength_function</span><span class="p">)</span>
                    <span class="n">mem_sv_winners</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cands_minus_b</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ws</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">ws</span> <span class="o">=</span> <span class="n">mem_sv_winners</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cands_minus_b</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ws</span><span class="p">:</span>
                    <span class="n">sv_winners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sv_winners</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sv_winners</span><span class="p">),</span> <span class="n">mem_sv_winners</span>
        
<div class="viewcode-block" id="stable_voting"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.stable_voting">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Stable Voting&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;Implementation of  Stable Voting from https://arxiv.org/abs/2108.00542. </span>

<span class="sd">    Stable Voting is a recursive voting method defined as follows: </span>

<span class="sd">    1.  If there is only one candidate in the profile, then that candidate is the winner. </span>
<span class="sd">    2. Order the pairs :math:`(a,b)` of candidates from largest to smallest value of the margin of :math:`a` over :math:`b` such that :math:`a` is undefeated according to Split Cycle, and declare as Stable Voting winners the candidate(s) :math:`a` from the earliest pair(s) :math:`(a,b)` such that :math:`a` is a Simple Stable Voting winner in the election without :math:`b`. </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.simple_stable_faster`, :meth:`pref_voting.margin_based_methods.simple_stable_voting`</span>


<span class="sd">    :Example: </span>

<span class="sd">    .. exec_code::</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import stable_voting</span>

<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 3, 8), (1, 0, 10), (2, 0, 4), (2, 1, 8), (3, 1, 8)])</span>

<span class="sd">        stable_voting.display(mg)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">,</span> <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="n">strength_function</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="stable_voting_faster"><a class="viewcode-back" href="../../margin_based_methods.html#pref_voting.margin_based_methods.stable_voting_faster">[docs]</a><span class="nd">@vm</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Stable Voting&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">stable_voting_faster</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stable Voting is Condorcet consistent.   It is faster to skip executing the recursive algorithm when there is a Condorcet winner.  </span>

<span class="sd">    Args:</span>
<span class="sd">        edata (Profile, ProfileWithTies, MarginGraph): Any election data that has a `margin` method. </span>
<span class="sd">        curr_cands (List[int], optional): If set, then find the winners for the profile restricted to the candidates in ``curr_cands``</span>
<span class="sd">        strength_function (function, optional): The strength function to be used to calculate the strength of a path.   The default is the margin method of ``edata``.   This only matters when the ballots are not linear orders. </span>

<span class="sd">    Returns: </span>
<span class="sd">        A sorted list of candidates. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`pref_voting.margin_based_methods.simple_stable_voting`, :meth:`pref_voting.margin_based_methods.stable_voting`</span>


<span class="sd">    :Example: </span>

<span class="sd">    .. exec_code::</span>

<span class="sd">        from pref_voting.weighted_majority_graphs import MarginGraph</span>
<span class="sd">        from pref_voting.margin_based_methods import stable_voting, stable_voting_faster</span>

<span class="sd">        mg = MarginGraph([0, 1, 2, 3], [(0, 3, 8), (1, 0, 10), (2, 0, 4), (2, 1, 8), (3, 1, 8)])</span>

<span class="sd">        stable_voting_faster.display(mg)</span>
<span class="sd">        stable_voting.display(mg)</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cw</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">condorcet_winner</span><span class="p">(</span><span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="k">return</span> <span class="p">[</span><span class="n">cw</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">_stable_voting</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">curr_cands</span> <span class="o">=</span> <span class="n">curr_cands</span><span class="p">,</span> <span class="n">mem_sv_winners</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">strength_function</span> <span class="o">=</span> <span class="n">strength_function</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>






<span class="n">mg_vms</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">minimax</span><span class="p">,</span> 
    <span class="n">split_cycle</span><span class="p">,</span>
    <span class="n">split_cycle_faster</span><span class="p">,</span>
    <span class="n">beat_path</span><span class="p">,</span>
    <span class="n">beat_path_faster</span><span class="p">,</span>
    <span class="c1">#ranked_pairs,</span>
    <span class="c1">#ranked_pairs_with_test,</span>
    <span class="n">ranked_pairs_zt</span><span class="p">,</span>
    <span class="n">ranked_pairs_tb</span><span class="p">,</span>
    <span class="c1">#river,</span>
    <span class="c1">#river_with_test, </span>
    <span class="n">simple_stable_voting</span><span class="p">,</span>
    <span class="n">simple_stable_voting_faster</span><span class="p">,</span>
    <span class="n">stable_voting</span><span class="p">,</span>
    <span class="n">stable_voting_faster</span><span class="p">,</span>
<span class="p">]</span>


<span class="n">mg_vms_all</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">minimax</span><span class="p">,</span> 
    <span class="n">split_cycle</span><span class="p">,</span>
    <span class="n">split_cycle_faster</span><span class="p">,</span>
    <span class="n">beat_path</span><span class="p">,</span>
    <span class="n">beat_path_faster</span><span class="p">,</span>
    <span class="n">ranked_pairs</span><span class="p">,</span>
    <span class="n">ranked_pairs_with_test</span><span class="p">,</span>
    <span class="n">ranked_pairs_zt</span><span class="p">,</span>
    <span class="n">ranked_pairs_tb</span><span class="p">,</span>
    <span class="n">river</span><span class="p">,</span>
    <span class="n">river_with_test</span><span class="p">,</span> 
    <span class="n">simple_stable_voting</span><span class="p">,</span>
    <span class="n">simple_stable_voting_faster</span><span class="p">,</span>
    <span class="n">stable_voting</span><span class="p">,</span>
    <span class="n">stable_voting_faster</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Eric Pacuit and Wes Holliday
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    </body>
</html>